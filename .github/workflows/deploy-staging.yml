name: Deploy Staging

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: deploy-staging
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

env:
  AZ_RESOURCE_GROUP: ${{ vars.AZ_RESOURCE_GROUP }}
  AZ_ACR_NAME: ${{ vars.AZ_ACR_NAME }}
  AZ_WEB_APP_NAME: ${{ vars.AZ_WEB_APP_NAME }}
  AZ_WORKER_APP_NAME: ${{ vars.AZ_WORKER_APP_NAME }}

jobs:
  detect_changes:
    runs-on: ubuntu-latest
    outputs:
      deploy_web: ${{ steps.changes.outputs.deploy_web }}
      deploy_worker: ${{ steps.changes.outputs.deploy_worker }}
      any: ${{ steps.changes.outputs.any }}
      db_sql_changed: ${{ steps.changes.outputs.db_sql_changed }}
      reason: ${{ steps.changes.outputs.reason }}
      changed_paths: ${{ steps.changes.outputs.changed_paths }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine deployment targets
        id: changes
        shell: bash
        run: |
          set -euo pipefail

          deploy_web=false
          deploy_worker=false
          db_sql_changed=false
          reason=""
          changed_paths=""

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            deploy_web=true
            deploy_worker=true
            db_sql_changed=false
            reason="workflow_dispatch"
            changed_paths="workflow_dispatch"
          else
            before="${{ github.event.before }}"
            if [[ -z "${before}" || "${before}" == "0000000000000000000000000000000000000000" ]]; then
              deploy_web=true
              deploy_worker=true
              reason="no before SHA available; deploying both"
              changed_paths="unknown"
            elif ! git cat-file -e "${before}^{commit}" 2>/dev/null; then
              deploy_web=true
              deploy_worker=true
              reason="before SHA missing locally; deploying both"
              changed_paths="unknown"
            else
              mapfile -t paths < <(git diff --name-only "${before}" "${GITHUB_SHA}")
              for path in "${paths[@]}"; do
                case "${path}" in
                  web/*) deploy_web=true ;;
                  worker/*) deploy_worker=true ;;
                esac
                if [[ "${path}" =~ ^db/.+\.sql$ ]]; then
                  db_sql_changed=true
                fi
              done
              if [[ ${#paths[@]} -gt 0 ]]; then
                changed_paths="$(printf '%s\n' "${paths[@]}" | paste -sd ',' -)"
              fi
              reason="diff ${before}..${GITHUB_SHA}"
            fi
          fi

          if [[ "${deploy_web}" == "true" || "${deploy_worker}" == "true" ]]; then
            any=true
          else
            any=false
          fi

          echo "deploy_web=${deploy_web}" >> "${GITHUB_OUTPUT}"
          echo "deploy_worker=${deploy_worker}" >> "${GITHUB_OUTPUT}"
          echo "any=${any}" >> "${GITHUB_OUTPUT}"
          echo "db_sql_changed=${db_sql_changed}" >> "${GITHUB_OUTPUT}"
          echo "reason=${reason}" >> "${GITHUB_OUTPUT}"
          echo "changed_paths=${changed_paths}" >> "${GITHUB_OUTPUT}"

      - name: Show deployment decision
        shell: bash
        run: |
          echo "deploy_web=${{ steps.changes.outputs.deploy_web }}"
          echo "deploy_worker=${{ steps.changes.outputs.deploy_worker }}"
          echo "any=${{ steps.changes.outputs.any }}"
          echo "db_sql_changed=${{ steps.changes.outputs.db_sql_changed }}"
          echo "reason=${{ steps.changes.outputs.reason }}"
          echo "changed_paths=${{ steps.changes.outputs.changed_paths }}"

  await_db_migration_approval:
    needs: detect_changes
    if: needs.detect_changes.outputs.db_sql_changed == 'true'
    runs-on: ubuntu-latest
    environment: staging-db-migrations
    steps:
      - name: Await manual DB migration confirmation
        shell: bash
        run: |
          echo "DB SQL changes were detected under db/**/*.sql."
          echo "Apply DB migrations externally, then approve this environment to continue deployment."
          echo "changed_paths=${{ needs.detect_changes.outputs.changed_paths }}"

  deploy:
    needs: [detect_changes, await_db_migration_approval]
    if: ${{ always() && (needs.detect_changes.outputs.db_sql_changed != 'true' || needs.await_db_migration_approval.result == 'success') }}
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        if: needs.detect_changes.outputs.deploy_web == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Web checks (tests + build)
        if: needs.detect_changes.outputs.deploy_web == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cd web
          npm ci
          npm test
          npm run build

      - name: Setup Python
        if: needs.detect_changes.outputs.deploy_worker == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Worker checks (tests + compile)
        if: needs.detect_changes.outputs.deploy_worker == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install -r worker/requirements.txt
          python -m unittest discover -s worker/tests -p "test_*.py"
          python -m py_compile worker/app/*.py worker/app/jobs/*.py

      - name: Azure Login (OIDC)
        if: needs.detect_changes.outputs.any == 'true'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure Azure CLI extensions
        if: needs.detect_changes.outputs.any == 'true'
        run: |
          az config set extension.use_dynamic_install=yes_without_prompt
          az extension add --name containerapp --upgrade

      - name: Validate required variables
        if: needs.detect_changes.outputs.any == 'true'
        shell: bash
        run: |
          set -euo pipefail
          for name in AZ_RESOURCE_GROUP AZ_ACR_NAME AZ_WEB_APP_NAME AZ_WORKER_APP_NAME; do
            if [[ -z "${!name:-}" ]]; then
              echo "Missing GitHub variable: ${name}" >&2
              exit 1
            fi
          done

      - name: Validate web staging runtime config
        if: needs.detect_changes.outputs.deploy_web == 'true'
        shell: bash
        env:
          STG_DATABASE_URL: ${{ secrets.STG_DATABASE_URL }}
          STG_ENTRA_CLIENT_SECRET: ${{ secrets.STG_ENTRA_CLIENT_SECRET }}
          STG_NEXTAUTH_SECRET: ${{ secrets.STG_NEXTAUTH_SECRET }}
          STG_WORKER_INTERNAL_API_TOKEN: ${{ secrets.STG_WORKER_INTERNAL_API_TOKEN }}
          STG_WORKER_HEARTBEAT_TOKEN: ${{ secrets.STG_WORKER_HEARTBEAT_TOKEN }}
          STG_ENTRA_TENANT_ID: ${{ vars.STG_ENTRA_TENANT_ID }}
          STG_ENTRA_CLIENT_ID: ${{ vars.STG_ENTRA_CLIENT_ID }}
          STG_ADMIN_GROUP_ID: ${{ vars.STG_ADMIN_GROUP_ID }}
          STG_USER_GROUP_ID: ${{ vars.STG_USER_GROUP_ID }}
          STG_INTERNAL_EMAIL_DOMAINS: ${{ vars.STG_INTERNAL_EMAIL_DOMAINS }}
          STG_DASHBOARD_DORMANT_LOOKBACK_DAYS: ${{ vars.STG_DASHBOARD_DORMANT_LOOKBACK_DAYS }}
        run: |
          set -euo pipefail
          required=(
            STG_DATABASE_URL
            STG_ENTRA_CLIENT_SECRET
            STG_NEXTAUTH_SECRET
            STG_WORKER_INTERNAL_API_TOKEN
            STG_WORKER_HEARTBEAT_TOKEN
            STG_ENTRA_TENANT_ID
            STG_ENTRA_CLIENT_ID
            STG_ADMIN_GROUP_ID
            STG_USER_GROUP_ID
            STG_INTERNAL_EMAIL_DOMAINS
            STG_DASHBOARD_DORMANT_LOOKBACK_DAYS
          )
          for name in "${required[@]}"; do
            if [[ -z "${!name:-}" ]]; then
              echo "Missing GitHub staging config: ${name}" >&2
              exit 1
            fi
          done

      - name: Validate worker staging runtime config
        if: needs.detect_changes.outputs.deploy_worker == 'true'
        shell: bash
        env:
          STG_DATABASE_URL: ${{ secrets.STG_DATABASE_URL }}
          STG_ENTRA_CLIENT_SECRET: ${{ secrets.STG_ENTRA_CLIENT_SECRET }}
          STG_WORKER_INTERNAL_API_TOKEN: ${{ secrets.STG_WORKER_INTERNAL_API_TOKEN }}
          STG_WORKER_HEARTBEAT_TOKEN: ${{ secrets.STG_WORKER_HEARTBEAT_TOKEN }}
          STG_ENTRA_TENANT_ID: ${{ vars.STG_ENTRA_TENANT_ID }}
          STG_ENTRA_CLIENT_ID: ${{ vars.STG_ENTRA_CLIENT_ID }}
          STG_INTERNAL_EMAIL_DOMAINS: ${{ vars.STG_INTERNAL_EMAIL_DOMAINS }}
          STG_DB_CONNECT_TIMEOUT_SECONDS: ${{ vars.STG_DB_CONNECT_TIMEOUT_SECONDS }}
          STG_SCHEDULER_POLL_SECONDS: ${{ vars.STG_SCHEDULER_POLL_SECONDS }}
          STG_GRAPH_BASE: ${{ vars.STG_GRAPH_BASE }}
          STG_GRAPH_MAX_CONCURRENCY: ${{ vars.STG_GRAPH_MAX_CONCURRENCY }}
          STG_GRAPH_MAX_RETRIES: ${{ vars.STG_GRAPH_MAX_RETRIES }}
          STG_GRAPH_CONNECT_TIMEOUT: ${{ vars.STG_GRAPH_CONNECT_TIMEOUT }}
          STG_GRAPH_READ_TIMEOUT: ${{ vars.STG_GRAPH_READ_TIMEOUT }}
          STG_GRAPH_PAGE_SIZE: ${{ vars.STG_GRAPH_PAGE_SIZE }}
          STG_GRAPH_PERMISSIONS_BATCH_SIZE: ${{ vars.STG_GRAPH_PERMISSIONS_BATCH_SIZE }}
          STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS: ${{ vars.STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS }}
          STG_FLUSH_EVERY: ${{ vars.STG_FLUSH_EVERY }}
        run: |
          set -euo pipefail
          required=(
            STG_DATABASE_URL
            STG_ENTRA_CLIENT_SECRET
            STG_WORKER_INTERNAL_API_TOKEN
            STG_WORKER_HEARTBEAT_TOKEN
            STG_ENTRA_TENANT_ID
            STG_ENTRA_CLIENT_ID
            STG_INTERNAL_EMAIL_DOMAINS
            STG_DB_CONNECT_TIMEOUT_SECONDS
            STG_SCHEDULER_POLL_SECONDS
            STG_GRAPH_BASE
            STG_GRAPH_MAX_CONCURRENCY
            STG_GRAPH_MAX_RETRIES
            STG_GRAPH_CONNECT_TIMEOUT
            STG_GRAPH_READ_TIMEOUT
            STG_GRAPH_PAGE_SIZE
            STG_GRAPH_PERMISSIONS_BATCH_SIZE
            STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS
            STG_FLUSH_EVERY
          )
          for name in "${required[@]}"; do
            if [[ -z "${!name:-}" ]]; then
              echo "Missing GitHub staging config: ${name}" >&2
              exit 1
            fi
          done

      - name: Sync web staging runtime config
        if: needs.detect_changes.outputs.deploy_web == 'true'
        shell: bash
        env:
          STG_DATABASE_URL: ${{ secrets.STG_DATABASE_URL }}
          STG_ENTRA_CLIENT_SECRET: ${{ secrets.STG_ENTRA_CLIENT_SECRET }}
          STG_NEXTAUTH_SECRET: ${{ secrets.STG_NEXTAUTH_SECRET }}
          STG_WORKER_INTERNAL_API_TOKEN: ${{ secrets.STG_WORKER_INTERNAL_API_TOKEN }}
          STG_WORKER_HEARTBEAT_TOKEN: ${{ secrets.STG_WORKER_HEARTBEAT_TOKEN }}
          STG_NEXTAUTH_URL: ${{ vars.STG_NEXTAUTH_URL }}
          STG_WORKER_API_URL: ${{ vars.STG_WORKER_API_URL }}
          STG_WORKER_HEARTBEAT_URL: ${{ vars.STG_WORKER_HEARTBEAT_URL || vars.WORKER_HEARTBEAT_URL }}
          STG_ENTRA_TENANT_ID: ${{ vars.STG_ENTRA_TENANT_ID }}
          STG_ENTRA_CLIENT_ID: ${{ vars.STG_ENTRA_CLIENT_ID }}
          STG_ADMIN_GROUP_ID: ${{ vars.STG_ADMIN_GROUP_ID }}
          STG_USER_GROUP_ID: ${{ vars.STG_USER_GROUP_ID }}
          STG_INTERNAL_EMAIL_DOMAINS: ${{ vars.STG_INTERNAL_EMAIL_DOMAINS }}
          STG_DASHBOARD_DORMANT_LOOKBACK_DAYS: ${{ vars.STG_DASHBOARD_DORMANT_LOOKBACK_DAYS }}
          STG_DB_CONNECT_TIMEOUT_SECONDS: ${{ vars.STG_DB_CONNECT_TIMEOUT_SECONDS }}
          STG_SCHEDULER_POLL_SECONDS: ${{ vars.STG_SCHEDULER_POLL_SECONDS }}
          STG_GRAPH_BASE: ${{ vars.STG_GRAPH_BASE }}
          STG_GRAPH_MAX_CONCURRENCY: ${{ vars.STG_GRAPH_MAX_CONCURRENCY }}
          STG_GRAPH_MAX_RETRIES: ${{ vars.STG_GRAPH_MAX_RETRIES }}
          STG_GRAPH_CONNECT_TIMEOUT: ${{ vars.STG_GRAPH_CONNECT_TIMEOUT }}
          STG_GRAPH_READ_TIMEOUT: ${{ vars.STG_GRAPH_READ_TIMEOUT }}
          STG_GRAPH_PAGE_SIZE: ${{ vars.STG_GRAPH_PAGE_SIZE }}
          STG_GRAPH_PERMISSIONS_BATCH_SIZE: ${{ vars.STG_GRAPH_PERMISSIONS_BATCH_SIZE }}
          STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS: ${{ vars.STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS }}
          STG_FLUSH_EVERY: ${{ vars.STG_FLUSH_EVERY }}
        run: |
          set -euo pipefail

          WEB_FQDN="$(az containerapp show \
            --name "${AZ_WEB_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)"

          NEXTAUTH_URL="${STG_NEXTAUTH_URL:-https://${WEB_FQDN}}"
          WORKER_API_URL="${STG_WORKER_API_URL:-http://${AZ_WORKER_APP_NAME}}"

          az containerapp secret set \
            --name "${AZ_WEB_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --secrets \
              dburl="${STG_DATABASE_URL}" \
              entrasecret="${STG_ENTRA_CLIENT_SECRET}" \
              nextauthsecret="${STG_NEXTAUTH_SECRET}" \
              workerinternaltoken="${STG_WORKER_INTERNAL_API_TOKEN}" \
              workerheartbeattoken="${STG_WORKER_HEARTBEAT_TOKEN}"

          az containerapp update \
            --name "${AZ_WEB_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --set-env-vars \
              DATABASE_URL=secretref:dburl \
              WORKER_API_URL="${WORKER_API_URL}" \
              WORKER_INTERNAL_API_TOKEN=secretref:workerinternaltoken \
              WORKER_HEARTBEAT_TOKEN=secretref:workerheartbeattoken \
              NEXTAUTH_URL="${NEXTAUTH_URL}" \
              NEXTAUTH_SECRET=secretref:nextauthsecret \
              ENTRA_TENANT_ID="${STG_ENTRA_TENANT_ID}" \
              ENTRA_CLIENT_ID="${STG_ENTRA_CLIENT_ID}" \
              ENTRA_CLIENT_SECRET=secretref:entrasecret \
              ADMIN_GROUP_ID="${STG_ADMIN_GROUP_ID}" \
              USER_GROUP_ID="${STG_USER_GROUP_ID}" \
              INTERNAL_EMAIL_DOMAINS="${STG_INTERNAL_EMAIL_DOMAINS}" \
              DASHBOARD_DORMANT_LOOKBACK_DAYS="${STG_DASHBOARD_DORMANT_LOOKBACK_DAYS}"

      - name: Sync worker staging runtime config
        if: needs.detect_changes.outputs.deploy_worker == 'true'
        shell: bash
        env:
          STG_DATABASE_URL: ${{ secrets.STG_DATABASE_URL }}
          STG_ENTRA_CLIENT_SECRET: ${{ secrets.STG_ENTRA_CLIENT_SECRET }}
          STG_WORKER_INTERNAL_API_TOKEN: ${{ secrets.STG_WORKER_INTERNAL_API_TOKEN }}
          STG_WORKER_HEARTBEAT_TOKEN: ${{ secrets.STG_WORKER_HEARTBEAT_TOKEN }}
          STG_WORKER_HEARTBEAT_URL: ${{ vars.STG_WORKER_HEARTBEAT_URL || vars.WORKER_HEARTBEAT_URL }}
          STG_ENTRA_TENANT_ID: ${{ vars.STG_ENTRA_TENANT_ID }}
          STG_ENTRA_CLIENT_ID: ${{ vars.STG_ENTRA_CLIENT_ID }}
          STG_INTERNAL_EMAIL_DOMAINS: ${{ vars.STG_INTERNAL_EMAIL_DOMAINS }}
          STG_DB_CONNECT_TIMEOUT_SECONDS: ${{ vars.STG_DB_CONNECT_TIMEOUT_SECONDS }}
          STG_SCHEDULER_POLL_SECONDS: ${{ vars.STG_SCHEDULER_POLL_SECONDS }}
          STG_GRAPH_BASE: ${{ vars.STG_GRAPH_BASE }}
          STG_GRAPH_MAX_CONCURRENCY: ${{ vars.STG_GRAPH_MAX_CONCURRENCY }}
          STG_GRAPH_MAX_RETRIES: ${{ vars.STG_GRAPH_MAX_RETRIES }}
          STG_GRAPH_CONNECT_TIMEOUT: ${{ vars.STG_GRAPH_CONNECT_TIMEOUT }}
          STG_GRAPH_READ_TIMEOUT: ${{ vars.STG_GRAPH_READ_TIMEOUT }}
          STG_GRAPH_PAGE_SIZE: ${{ vars.STG_GRAPH_PAGE_SIZE }}
          STG_GRAPH_PERMISSIONS_BATCH_SIZE: ${{ vars.STG_GRAPH_PERMISSIONS_BATCH_SIZE }}
          STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS: ${{ vars.STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS }}
          STG_FLUSH_EVERY: ${{ vars.STG_FLUSH_EVERY }}
        run: |
          set -euo pipefail

          WEB_FQDN="$(az containerapp show \
            --name "${AZ_WEB_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)"

          WORKER_HEARTBEAT_URL="${STG_WORKER_HEARTBEAT_URL:-https://${WEB_FQDN}/api/internal/worker-heartbeat}"

          az containerapp secret set \
            --name "${AZ_WORKER_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --secrets \
              dburl="${STG_DATABASE_URL}" \
              entrasecret="${STG_ENTRA_CLIENT_SECRET}" \
              workerinternaltoken="${STG_WORKER_INTERNAL_API_TOKEN}" \
              workerheartbeattoken="${STG_WORKER_HEARTBEAT_TOKEN}"

          az containerapp update \
            --name "${AZ_WORKER_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --set-env-vars \
              DATABASE_URL=secretref:dburl \
              WORKER_INTERNAL_API_TOKEN=secretref:workerinternaltoken \
              WORKER_HEARTBEAT_TOKEN=secretref:workerheartbeattoken \
              DB_CONNECT_TIMEOUT_SECONDS="${STG_DB_CONNECT_TIMEOUT_SECONDS}" \
              SCHEDULER_POLL_SECONDS="${STG_SCHEDULER_POLL_SECONDS}" \
              ENTRA_TENANT_ID="${STG_ENTRA_TENANT_ID}" \
              ENTRA_CLIENT_ID="${STG_ENTRA_CLIENT_ID}" \
              ENTRA_CLIENT_SECRET=secretref:entrasecret \
              INTERNAL_EMAIL_DOMAINS="${STG_INTERNAL_EMAIL_DOMAINS}" \
              GRAPH_BASE="${STG_GRAPH_BASE}" \
              GRAPH_MAX_CONCURRENCY="${STG_GRAPH_MAX_CONCURRENCY}" \
              GRAPH_MAX_RETRIES="${STG_GRAPH_MAX_RETRIES}" \
              GRAPH_CONNECT_TIMEOUT="${STG_GRAPH_CONNECT_TIMEOUT}" \
              GRAPH_READ_TIMEOUT="${STG_GRAPH_READ_TIMEOUT}" \
              GRAPH_PAGE_SIZE="${STG_GRAPH_PAGE_SIZE}" \
              GRAPH_PERMISSIONS_BATCH_SIZE="${STG_GRAPH_PERMISSIONS_BATCH_SIZE}" \
              GRAPH_PERMISSIONS_STALE_AFTER_HOURS="${STG_GRAPH_PERMISSIONS_STALE_AFTER_HOURS}" \
              FLUSH_EVERY="${STG_FLUSH_EVERY}" \
              WORKER_HEARTBEAT_URL="${WORKER_HEARTBEAT_URL}"

      - name: Prepare image tag
        if: needs.detect_changes.outputs.any == 'true'
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_TAG="${GITHUB_SHA::12}"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> "${GITHUB_ENV}"

      - name: Build and push web image to ACR
        if: needs.detect_changes.outputs.deploy_web == 'true'
        shell: bash
        run: |
          set -euo pipefail
          az acr build \
            --registry "${AZ_ACR_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --image "sentinel-web:${IMAGE_TAG}" \
            ./web

      - name: Build and push worker image to ACR
        if: needs.detect_changes.outputs.deploy_worker == 'true'
        shell: bash
        run: |
          set -euo pipefail
          az acr build \
            --registry "${AZ_ACR_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --image "sentinel-worker:${IMAGE_TAG}" \
            ./worker

      - name: Resolve ACR login server
        if: needs.detect_changes.outputs.any == 'true'
        id: acr
        shell: bash
        run: |
          set -euo pipefail
          ACR_LOGIN_SERVER="$(az acr show \
            --name "${AZ_ACR_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --query "loginServer" \
            --output tsv)"
          echo "login_server=${ACR_LOGIN_SERVER}" >> "${GITHUB_OUTPUT}"

      - name: Update web app to new image
        if: needs.detect_changes.outputs.deploy_web == 'true'
        shell: bash
        run: |
          set -euo pipefail
          az containerapp update \
            --name "${AZ_WEB_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --image "${{ steps.acr.outputs.login_server }}/sentinel-web:${IMAGE_TAG}"

      - name: Update worker app to new image
        if: needs.detect_changes.outputs.deploy_worker == 'true'
        shell: bash
        run: |
          set -euo pipefail
          az containerapp update \
            --name "${AZ_WORKER_APP_NAME}" \
            --resource-group "${AZ_RESOURCE_GROUP}" \
            --image "${{ steps.acr.outputs.login_server }}/sentinel-worker:${IMAGE_TAG}"

      - name: Show deployed revisions
        if: needs.detect_changes.outputs.any == 'true'
        shell: bash
        env:
          DEPLOY_WEB: ${{ needs.detect_changes.outputs.deploy_web }}
          DEPLOY_WORKER: ${{ needs.detect_changes.outputs.deploy_worker }}
        run: |
          if [[ "${DEPLOY_WEB}" == "true" ]]; then
            az containerapp show \
              --name "${AZ_WEB_APP_NAME}" \
              --resource-group "${AZ_RESOURCE_GROUP}" \
              --query "{app:name,latestRevision:properties.latestRevisionName}" \
              --output table
          fi

          if [[ "${DEPLOY_WORKER}" == "true" ]]; then
            az containerapp show \
              --name "${AZ_WORKER_APP_NAME}" \
              --resource-group "${AZ_RESOURCE_GROUP}" \
              --query "{app:name,latestRevision:properties.latestRevisionName}" \
              --output table
          fi

      - name: Skip deploy when no app changes are detected
        if: needs.detect_changes.outputs.any != 'true'
        shell: bash
        run: echo "No changes under web/ or worker/. Skipping staging deployment."
